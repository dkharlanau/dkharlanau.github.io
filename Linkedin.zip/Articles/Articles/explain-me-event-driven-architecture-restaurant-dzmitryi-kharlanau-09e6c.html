<html>
<head>
  <title>Explain me Event-Driven Architecture â€” with Restaurant Analogy</title>
  <style>
    body {
      margin: 0 auto;
      width: 744px;
      font-family: Source Serif Pro, serif;
      line-height: 32px;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.7);
      font-size: 21px;
    }
    h1, h2, h3 {
      font-family: Source Sans Pro, Helvetica, Arial, sans-serif;
    }
    h1 a, h1 a:visited {
      color: inherit;
      text-decoration: none;
    }
    h1 {
      line-height: 48px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 42px;
      margin: 32px 0 20px;
    }
    h2 {
      line-height: 32px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 26px;
      margin: 28px 0;
    }
    h3 {
      line-height: 28px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 21px;
      margin: 24px 0;
    }
    p {
      margin: 32px 0;
    }
    .created, .published {
      color: rgba(0, 0, 0, 0.55);
      font-size: 15px;
      line-height: 15px;
      margin: 20px 0;
    }
    .created + .published {
      margin-top: -12px;
    }
    blockquote {
      font-family: Georgia, Source Serif Pro, serif;
      font-style: italic;
      font-size: 24px;
      line-height: 36px;
      margin: 48px 120px;
      text-align: center;
    }
    a {
      word-wrap: break-word;
      outline: none;
      text-decoration: none;
      background-color: transparent;
      border: 0;
      color: #008CC9;
    }
    a:hover {
      text-decoration: underline;
    }
    a:visited {
      color: #8C68CB;
    }
    .center {
      text-align: center;
    }
    iframe {
      display: block;
      margin: 44px auto;
    }
    *:not(pre) + pre, pre:first-of-type {
      margin-top: 32px;
      padding-top: 32px;
    }
    pre:only-of-type {
      margin: 32px 0;
      padding: 32px;
    }
    pre {
      background: #F3F6F8;
      overflow-x: auto;
      display: block;
      font-size: 13px;
      font-family: monospace;
      line-height: 13px;
      padding: 0 32px 32px;
      white-space: pre;
    }
    a.embedded {
      background: #F3F6F8;
      display: block;
      padding: 32px;
      margin: 32px 0;
    }
    img {
      height: auto;
      max-width: 100%;
    }
    .slate-image-embed__resize-full-width img {
      width: 100%;
    }
    .series-logo {
      width: 48px;
      height: 48px;
      box-sizing: border-box;
      background-clip: content-box;
      border: 4px solid transparent;
      border-radius: 6px;
      object-fit: scale-down;
      float: left;
    }
    .series-title {
      font-size: 16px;
      font-weight: 600;
      vertical-align: top;
    }
    .series-description {
      color: rgba(0,0,0,.6);
      font-weight: 400;
      font-size: 14px;
      line-height: 20px;
    }
    div {
      margin: 32px 0;
    }
  </style>
</head>
<body>
    <img src="https://media.licdn.com/mediaD5612AQHzfwidU8fL7g" alt="" title="" />
      <h1><a href="https://www.linkedin.com/pulse/explain-me-event-driven-architecture-restaurant-dzmitryi-kharlanau-09e6c">Explain me Event-Driven Architecture â€” with Restaurant Analogy</a></h1>
    <p class="created">Created on 2025-08-01 11:02</p>
  <p class="published">Published on 2025-08-01 16:30</p>
  <div><p>Event-Driven Architecture (EDA) is a design pattern where system components donâ€™t call each other directly. Instead, they communicate by <strong>emitting and reacting to events</strong> â€” messages that say:</p><pre></pre><p>Each component listens for the events it cares about and acts â€” independently.</p><h2>Restaurant Analogy</h2><p>Letâ€™s map a typical restaurant process to this architecture:</p><figure><img data-media-urn="urn:li:digitalmediaAsset:D5612AQHaynjNhm6TbQ" src="https://media.licdn.com/dms/image/v2/D5612AQHaynjNhm6TbQ/article-inline_image-shrink_1000_1488/B56ZhlTUaQG0AU-/0/1754046220487?e=1762387200&amp;v=beta&amp;t=8A7os16rNln5-16grYhyO3Yp6z-hwJkwiWq94tQQv_o"><figcaption></figcaption></figure><p>Nobody waits for a reply. Everyone reacts to the same signal. </p><figure><img data-media-urn="urn:li:digitalmediaAsset:D5612AQGFh5gnTBIVCw" src="https://media.licdn.com/dms/image/v2/D5612AQGFh5gnTBIVCw/article-inline_image-shrink_1000_1488/B56ZhlVBzUH0AQ-/0/1754046668708?e=1762387200&amp;v=beta&amp;t=8quW9H5MTGsUOxQnlsrPNxsHgE-r6DdvCRgY-ziUG-Q"><figcaption></figcaption></figure><h2>What is an Event Message?</h2><p>An <strong>event</strong> isnâ€™t just a signal â€” itâ€™s a structured <strong>message</strong>. It includes not only the event <strong>type</strong> (â€œOrderPlacedâ€), but also the <strong>payload</strong> â€” the actual business object involved.</p><p>Example</p><pre></pre><p>Key elements:</p><ul><li><p><strong>eventType</strong> â€” semantic name of the event</p></li><li><p><strong>timestamp</strong> â€” when it happened</p></li><li><p><strong>ID(s)</strong> â€” to track objects across systems</p></li><li><p><strong>payload</strong> â€” structured business object snapshot</p></li><li><p><strong>source</strong> â€” optional, useful for tracing</p></li></ul><p>This is what the event <strong>actually looks like</strong> when published to Kafka, SAP Event Mesh, etc.</p><p></p><h2>When Is an Event Created?</h2><p>An event should be emitted:</p><ul><li><p><strong>after</strong> a business action is successfully completed (e.g. after DB commit or API call)</p></li><li><p><strong>as soon as</strong> a state change occurs that others should know about</p></li></ul><p><strong>In SAP systems</strong>, events may be emitted:</p><ul><li><p>After  completes</p></li><li><p>From an ABAP user exit or enhancement spot</p></li><li><p>In a CAP service handler (e.g. )</p></li><li><p>From CPI (Cloud Platform Integration) or BTP Workflow</p></li></ul><p></p><h2>Who Emits the Event?</h2><p>Can be:</p><ul><li><p>A backend system (S/4HANA, Sales Cloud, etc.)</p></li><li><p>A microservice</p></li><li><p>A middleware platform (e.g. CPI or PI/PO)</p></li><li><p>A user action (via frontend/UI)</p></li></ul><p>The rule is: <strong>whoever knows first that â€œX happenedâ€ â€” emits the event</strong>.</p><p></p><h2>What Happens After the Event Is Emitted?</h2><ol><li><p><strong>Producer</strong> emits the event</p></li><li><p><strong>Event Broker</strong> (e.g. Kafka, SAP Event Mesh) receives and routes it</p></li><li><p><strong>Consumers</strong> receive and process it</p></li><li><p><strong>Optional</strong>: Consumers emit follow-up events (, , )</p></li></ol><p>Each consumer is isolated and doesn't know who else is reacting.</p><p></p><h2>How Do You Know It Worked?</h2><p>Unlike REST, EDA doesnâ€™t give you a synchronous response. There is no .</p><p>So you need to <strong>design for confirmation</strong>.</p><p><strong>Pattern 1: Follow-up Events</strong></p><p>Each consumer sends a new event when it finishes its job:</p><ul><li><p>Kitchen emits </p></li><li><p>Billing emits </p></li><li><p>Notification emits </p></li></ul><p>This creates a <strong>chain of events</strong> â€” traceable and auditable.</p><p><strong>Pattern 2: Status Logging</strong></p><p>Consumers log the processing result into a central table/log.</p><p><strong>Pattern 3: Dead Letter Queues (DLQ)</strong></p><p>If a consumer fails multiple times, the event is sent to a <strong>DLQ</strong>. This allows operations teams to monitor failed events and reprocess them later.</p><p><strong>Pattern 4: Timeouts &amp; Monitoring</strong></p><p>If no follow-up event is received within expected time (e.g. 5 min), raise an alert. This is critical for processes like shipping, billing, compliance.</p><p></p><h2>When to Use EDA</h2><p>Best used when:</p><ul><li><p>Many services react to the same data (e.g. O2C, onboarding, logistics)</p></li><li><p>Real-time processing is critical</p></li><li><p>You want to add new functionality without breaking what exists</p></li></ul><p></p><blockquote><p>An event is more than a signal â€” it's a structured message that carries business meaning. The architecture only works well if you <strong>design your events</strong> with care: naming, payload, delivery guarantees, and status confirmation.</p></blockquote><p></p><p>This is <strong>fully asynchronous</strong>. Because it's async:</p><ul><li><p>You <strong>must</strong> design for <strong>eventual consistency</strong> (e.g. invoice might come 2 seconds after order creation)</p></li><li><p>You <strong>can't rely on order</strong> unless explicitly handled (Kafka can preserve order <em>per key</em>; others canâ€™t)</p></li><li><p>You <strong>need monitoring</strong> to know if something failed (there's no synchronous "response")</p></li></ul><hr><p>Here's the list of <strong>EDA terms with short descriptions</strong>, clear and practical â€” line by line:</p><hr><h3>ğŸ”¹ Core Terms</h3><ul><li><p><strong>Event</strong> â€” Notification that something happened ("OrderPlaced").</p></li><li><p><strong>Event Message</strong> â€” The full message sent, includes metadata + payload.</p></li><li><p><strong>Event Type</strong> â€” The name/category of the event (e.g. ).</p></li><li><p><strong>Payload</strong> â€” Business data inside the event (e.g. order details).</p></li><li><p><strong>Schema</strong> â€” Structure of the payload (fields, types, format).</p></li><li><p><strong>Metadata</strong> â€” Extra info like timestamp, source, event ID.</p></li></ul><hr><h3>ğŸ”¹ Participants</h3><ul><li><p><strong>Producer</strong> â€” Sends the event after something happens.</p></li><li><p><strong>Consumer</strong> â€” Listens for events and reacts to them.</p></li><li><p><strong>Event Broker</strong> â€” Middleware that routes events (e.g. Kafka, Event Mesh).</p></li><li><p><strong>Subscriber</strong> â€” A consumer that registered for a specific event.</p></li></ul><hr><h3>ğŸ”¹ Messaging Components</h3><ul><li><p><strong>Topic</strong> â€” Logical channel where events are published.</p></li><li><p><strong>Queue</strong> â€” FIFO structure to buffer events (used in point-to-point).</p></li><li><p><strong>Subscription</strong> â€” Connection between consumer and topic.</p></li><li><p><strong>Partition</strong> â€” Kafka-specific sub-channel for scaling topics.</p></li><li><p><strong>Offset</strong> â€” Position of an event inside a Kafka partition.</p></li></ul><hr><h3>ğŸ”¹ Delivery &amp; Reliability</h3><ul><li><p><strong>At-least-once</strong> â€” Might get duplicate events, but never miss.</p></li><li><p><strong>At-most-once</strong> â€” No duplicates, but risk of lost events.</p></li><li><p><strong>Exactly-once</strong> â€” Processed one time only (complex to achieve).</p></li><li><p><strong>Retry Policy</strong> â€” How the system handles failed delivery.</p></li><li><p><strong>Dead Letter Queue (DLQ)</strong> â€” Stores events that failed too many times.</p></li><li><p><strong>Acknowledgment (ACK)</strong> â€” Signal from consumer: â€œI processed this.â€</p></li></ul><hr><h3>ğŸ”¹ Behavior &amp; Patterns</h3><ul><li><p><strong>Asynchronous Processing</strong> â€” Producer doesnâ€™t wait for consumers.</p></li><li><p><strong>Eventual Consistency</strong> â€” All systems reach the same state over time.</p></li><li><p><strong>Idempotency</strong> â€” Same event processed multiple times = same result.</p></li><li><p><strong>Fan-out</strong> â€” One event triggers many consumers.</p></li><li><p><strong>Event Choreography</strong> â€” Services coordinate via events (no central control).</p></li><li><p><strong>Event Orchestration</strong> â€” Central engine controls event flow.</p></li><li><p><strong>Event Sourcing</strong> â€” State is rebuilt from event history.</p></li><li><p><strong>CQRS</strong> â€” Split between read and write models, often used with events.</p></li></ul><hr><h3>ğŸ”¹ Monitoring &amp; Observability</h3><ul><li><p><strong>Tracing</strong> â€” Following an event through the system.</p></li><li><p><strong>Correlation ID</strong> â€” Identifier to connect related events.</p></li><li><p><strong>Audit Log</strong> â€” Stores records of all events for traceability.</p></li><li><p><strong>Tracking Dashboard</strong> â€” Visual view of event flow and status.</p></li></ul><hr><h3>ğŸ”¹ Tools (Examples)</h3><ul><li><p><strong>Apache Kafka</strong> â€” Distributed event streaming platform.</p></li><li><p><strong>SAP Event Mesh</strong> â€” SAPâ€™s managed event broker (based on MQTT/AMQP).</p></li><li><p><strong>RabbitMQ</strong> â€” Lightweight message broker (queue-based).</p></li><li><p><strong>AWS SNS/SQS</strong> â€” Amazonâ€™s pub/sub and queue services.</p></li><li><p><strong>SAP BTP</strong> â€” Platform for deploying producers/consumers.</p></li><li><p><strong>SAP CAP</strong> â€” Framework for services with native event support.</p></li><li><p><strong>SAP CPI</strong> â€” Integration tool that can produce/consume events.</p></li></ul><p></p></div>
</body>
</html>